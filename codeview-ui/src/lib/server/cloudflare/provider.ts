import { Result } from 'better-result';
import type { RequestEvent } from '@sveltejs/kit';
import type { Confidence, CrateGraph, EdgeKind, NodeKind, Visibility, Workspace } from '$lib/graph';
import type { CrateIndex } from '$lib/schema';
import { parseWorkspace } from '$lib/schema';
import { isStdCrate, isRustChannel } from '$lib/std';
import type { CrossEdgeData, DataProvider } from '../provider';
import type { GraphStore } from '$cloudflare/store';
import type { CrateRegistry } from '$cloudflare/registry';
import type { Ecosystem } from '../registry/types';
import { getRegistry } from '../registry/index';
import { ValidationError, NotAvailableError, RateLimitError } from '../errors';
import { checkRateLimitPolicy } from './ratelimit';
import { isValidCrateName, isValidVersion, crateNameVariants } from '../validation';
import { getLogger } from '$lib/log';

const log = getLogger('cloudflare');

/**
 * Narrows the global Env (generated by `wrangler types`) with typed DO/Workflow
 * generics and optional secrets that aren't declared in wrangler.toml.
 */
type AppEnv = Omit<Env, 'GRAPH_STORE' | 'CRATE_REGISTRY' | 'PARSE_CRATE'> & {
	GRAPH_STORE: DurableObjectNamespace<GraphStore>;
	CRATE_REGISTRY: DurableObjectNamespace<CrateRegistry>;
	PARSE_CRATE: Workflow<{ ecosystem: Ecosystem; name: string; version: string }>;
	GITHUB_REPO?: string;
	GITHUB_REF?: string;
	GITHUB_TOKEN?: string;
};

async function resolveStdVersion(
	r2: R2Bucket, name: string, version: string
): Promise<string | null> {
	if (!isStdCrate(name) || !isRustChannel(version)) return version;
	const obj = await r2.get(`rust/${name}/${version}.json`);
	if (!obj) return null;
	const pointer = await obj.json<{ version: string }>();
	return pointer.version ?? null;
}

function proxyDO(
	registryStub: DurableObjectStub<CrateRegistry>,
	key: string,
	signal: AbortSignal
): Promise<Response> {
	return registryStub.fetch(
		new Request('https://do/sse?key=' + encodeURIComponent(key), { signal })
	);
}

export function createCloudflareProvider(env: AppEnv, event?: RequestEvent): DataProvider {
	const graphStub = env.GRAPH_STORE.get(env.GRAPH_STORE.idFromName('default'));

	const registryStub = env.CRATE_REGISTRY.get(env.CRATE_REGISTRY.idFromName('global'));

	return {
		async loadWorkspace() {
			const json = await graphStub.getGraph();
			if (!json) return null;
			const result = Result.try(() => parseWorkspace(json) as Workspace);
			if (result.isErr()) {
				log.error`Failed to parse workspace: ${result.error}`;
				return null;
			}
			return result.value;
		},

		async loadSourceFile(relativePath: string) {
			// Check DO cache first
			const cachedFile = await graphStub.getSourceFile(relativePath);
			if (cachedFile) return { error: null, content: cachedFile };

			// Resolve repo info from env or workspace metadata
			const workspace = await this.loadWorkspace();
			const repo = env.GITHUB_REPO ?? workspace?.repo;
			const ref_ = env.GITHUB_REF ?? workspace?.ref ?? 'main';

			if (!repo) {
				return { error: 'No GitHub repo configured for source viewing', content: null };
			}

			// Fetch from GitHub API
			const url = `https://api.github.com/repos/${repo}/contents/${relativePath}?ref=${ref_}`;
			const headers: Record<string, string> = {
				Accept: 'application/vnd.github.raw+json',
				'User-Agent': 'codeview'
			};
			if (env.GITHUB_TOKEN) {
				headers['Authorization'] = `Bearer ${env.GITHUB_TOKEN}`;
			}

			const fetchResult = await Result.tryPromise(async () => {
				const response = await fetch(url, { headers });
				if (!response.ok) {
					throw new Error(`GitHub API returned ${response.status}`);
				}
				return response.text();
			});
			if (fetchResult.isErr()) {
				return { error: 'Failed to fetch source from GitHub', content: null };
			}
			const content = fetchResult.value;

			// Cache in DO (fire-and-forget)
			graphStub.cacheSourceFile(relativePath, content).catch(() => {});

			return { error: null, content };
		},

		async loadCrateGraph(name: string, version: string) {
			const resolved = await resolveStdVersion(env.CRATE_GRAPHS, name, version);
			if (!resolved) return null;

			const key = `rust/${name}/${resolved}/graph.json`;
			const obj = await env.CRATE_GRAPHS.get(key);
			if (!obj) return null;

			const result = await Result.tryPromise(() => obj.json<CrateGraph>());
			if (result.isErr()) {
				log.error`Failed to parse crate graph from R2 (${key}): ${result.error}`;
				return null;
			}
			return result.value;
		},

		async loadCrateIndex(name: string, version: string): Promise<CrateIndex | null> {
			const resolved = await resolveStdVersion(env.CRATE_GRAPHS, name, version);
			if (!resolved) return null;

			const key = `rust/${name}/${resolved}/index.json`;
			const obj = await env.CRATE_GRAPHS.get(key);
			if (!obj) return null;
			const result = await Result.tryPromise(() => obj.json<CrateIndex>());
			if (result.isErr()) {
				log.error`Failed to parse crate index from R2 (${key}): ${result.error}`;
				return null;
			}
			return result.value;
		},

		async getCrossEdgeData(nodeId: string): Promise<CrossEdgeData> {
			const result = await registryStub.getCrossEdgeData('rust', nodeId);
			return {
				edges: result.edges.map((edge) => ({
					...edge,
					kind: edge.kind as EdgeKind,
					confidence: edge.confidence as Confidence
				})),
				nodes: result.nodes.map((node) => ({
					...node,
					kind: node.kind as NodeKind,
					visibility: node.visibility as Visibility
				}))
			};
		},

		async getCrateStatus(name: string, version: string) {
			// Std crates are pre-built via CI — check R2 directly instead of registry
			if (isStdCrate(name)) {
				const resolved = await resolveStdVersion(env.CRATE_GRAPHS, name, version);
				if (resolved) {
					const head = await env.CRATE_GRAPHS.head(`rust/${name}/${resolved}/graph.json`);
					if (head) return { status: 'ready' as const };
				}
				return {
					status: 'failed' as const,
					error: `Std crate ${name}@${version} not available. Pre-built graphs are generated via CI.`
				};
			}
			const current = await registryStub.getStatus('rust', name, version);
			// Auto-trigger parse for unknown crates
			if (current.status === 'unknown' && isValidCrateName(name) && isValidVersion(version)) {
				await Promise.all([
					registryStub.setStatus('rust', name, version, 'processing'),
					env.PARSE_CRATE.create({ params: { ecosystem: 'rust' as const, name, version } })
				]);
				return { status: 'processing' as const };
			}
			return current;
		},

		async triggerParse(name: string, version: string, force?: boolean) {
			if (isStdCrate(name)) {
				return Result.err(new NotAvailableError({ message: `${name} is a standard library crate and cannot be parsed on-demand` }));
			}
			if (!isValidCrateName(name) || !isValidVersion(version)) {
				return Result.err(new ValidationError({ message: 'Invalid crate name or version' }));
			}

			if (event) {
				const allowed = await checkRateLimitPolicy(event, 'parse');
				if (!allowed) {
					return Result.err(new RateLimitError({ message: 'Rate limit exceeded' }));
				}
			}

			if (!force) {
				const current = await registryStub.getStatus('rust', name, version);
				if (current.status === 'processing' || current.status === 'ready') return Result.ok(undefined);
			}

			// Set status and trigger workflow concurrently
			await Promise.all([
				registryStub.setStatus('rust', name, version, 'processing'),
				env.PARSE_CRATE.create({ params: { ecosystem: 'rust', name, version } })
			]);
			return Result.ok(undefined);
		},

		async triggerStdInstall(_name: string, _version: string) {
			return Result.err(new NotAvailableError({ message: 'std crate installation is not available in hosted mode' }));
		},

		async searchRegistry(query: string) {
			const registryResult = getRegistry('rust');
			if (registryResult.isErr()) return [];
			const results = await registryResult.value.search(query);
			return results.map((r) => ({
				name: r.name,
				version: r.version,
				description: r.description
			}));
		},

		async getTopCrates(limit = 10) {
			const registryResult = getRegistry('rust');
			if (registryResult.isErr()) return [];
			const results = await registryResult.value.listTop(limit);
			return results.map((r) => ({
				name: r.name,
				version: r.version,
				description: r.description
			}));
		},

		async getProcessingCrates(limit = 20) {
			return await registryStub.getProcessingCrates('rust', limit);
		},

		async streamCrateStatus(name: string, version: string, signal: AbortSignal): Promise<Response> {
			// Auto-trigger parse for unknown crates
			await this.getCrateStatus(name, version);
			return proxyDO(registryStub, `rust:${name}:${version}`, signal);
		},

		async streamProcessingStatus(ecosystem: string, signal: AbortSignal): Promise<Response> {
			return proxyDO(registryStub, `processing:${ecosystem}`, signal);
		},

		async streamEdgeUpdates(nodeId: string, signal: AbortSignal): Promise<Response> {
			return proxyDO(registryStub, `edge:${nodeId}`, signal);
		},

		async getCrateVersions(name: string, limit = 20): Promise<string[]> {
			if (isStdCrate(name)) {
				// Check all channels concurrently
				const channelNames = ['stable', 'nightly', 'beta'] as const;
				const results = await Promise.all(
					channelNames.map((ch) => env.CRATE_GRAPHS.head(`rust/${name}/${ch}.json`))
				);
				const channels = channelNames.filter((_, i) => results[i] !== null);
				return channels.length > 0 ? channels : ['stable'];
			}
			const registryResult = getRegistry('rust');
			if (registryResult.isErr()) return [];
			// Try both hyphen and underscore variants for registry lookup
			for (const variant of crateNameVariants(name)) {
				const versions = await registryResult.value.listVersions(variant, limit);
				if (versions.length > 0) return versions;
			}
			return [];
		}
	};
}

/** Build-time entry point — imported via the `$provider` alias (see vite.config.js). */
export function createProvider(event: RequestEvent): DataProvider {
	const env = (event.platform as { env: AppEnv }).env;
	return createCloudflareProvider(env, event);
}
